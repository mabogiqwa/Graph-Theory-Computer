<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>Graph Isomorphism Checker</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .container {
            background: white;
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            max-width: 1200px;
            width: 100%;
        }

        h1 {
            text-align: center;
            color: #667eea;
            margin-bottom: 10px;
            font-size: 2em;
        }

        .instructions {
            text-align: center;
            color: #666;
            margin-bottom: 25px;
            font-size: 0.95em;
        }

        .graphs-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 25px;
        }

        .graph-panel {
            border: 2px solid #e0e0e0;
            border-radius: 12px;
            padding: 15px;
            background: #f9f9f9;
        }

        .graph-title {
            font-weight: bold;
            color: #667eea;
            margin-bottom: 10px;
            text-align: center;
        }

        canvas {
            border: 2px solid #667eea;
            border-radius: 8px;
            background: white;
            cursor: crosshair;
            display: block;
            width: 100%;
            height: 350px;
        }

        .controls {
            display: flex;
            gap: 10px;
            justify-content: center;
            flex-wrap: wrap;
            margin-top: 15px;
        }

        button {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            font-size: 0.95em;
        }

        .btn-primary {
            background: #667eea;
            color: white;
        }

        .btn-primary:hover {
            background: #5568d3;
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }

        .btn-secondary {
            background: #e0e0e0;
            color: #333;
        }

        .btn-secondary:hover {
            background: #d0d0d0;
        }

        .btn-danger {
            background: #ff4757;
            color: white;
        }

        .btn-danger:hover {
            background: #ee5a6f;
        }

        .mode-selector {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin-bottom: 20px;
        }

        .mode-btn {
            padding: 10px 20px;
            border: 2px solid #667eea;
            background: white;
            color: #667eea;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
        }

        .mode-btn.active {
            background: #667eea;
            color: white;
        }

        .result {
            margin-top: 25px;
            padding: 20px;
            border-radius: 12px;
            text-align: center;
            font-weight: bold;
            font-size: 1.2em;
            display: none;
        }

        .result.isomorphic {
            background: #d4edda;
            color: #155724;
            border: 2px solid #c3e6cb;
            display: block;
        }

        .result.not-isomorphic {
            background: #f8d7da;
            color: #721c24;
            border: 2px solid #f5c6cb;
            display: block;
        }

        .planarity-result {
            margin-top: 25px;
            padding: 20px;
            border-radius: 12px;
            text-align: center;
            font-weight: bold;
            font-size: 1.2em;
            display: none;
        }

        .planarity-result.planar {
            background: #d4edda;
            color: #155724;
            border: 2px solid #c3e6cb;
            display: block;
        }

        .planarity-result.non-planar {
            background: #f8d7da;
            color: #721c24;
            border: 2px solid #f5c6cb;
            display: block;
        }

        .properties-result {
            margin-top: 25px;
            padding: 20px;
            border-radius: 12px;
            font-size: 1em;
            display: none;
            background: #e7f3ff;
            border: 2px solid #b3d9ff;
            color: #004085;
        }

        .properties-result.show {
            display: block;
        }

        .property-section {
            margin-bottom: 15px;
            padding: 15px;
            background: white;
            border-radius: 8px;
            border-left: 4px solid #667eea;
        }

        .property-title {
            font-weight: bold;
            color: #667eea;
            margin-bottom: 8px;
            font-size: 1.1em;
        }

        .property-detail {
            margin: 5px 0;
            padding-left: 10px;
        }

        .property-yes {
            color: #155724;
            font-weight: 600;
        }

        .property-no {
            color: #721c24;
            font-weight: 600;
        }

        .mst-result, .euler-result {
            margin-top: 25px;
            padding: 20px;
            border-radius: 12px;
            font-size: 1em;
            display: none;
            background: #e7f3ff;
            border: 2px solid #b3d9ff;
            color: #004085;
        }

        .mst-result.show, .euler-result.show {
            display: block;
        }

        .path-highlight {
            color: #667eea;
            font-weight: bold;
        }

        .info {
            background: #e7f3ff;
            border: 2px solid #b3d9ff;
            border-radius: 8px;
            padding: 15px;
            margin-top: 15px;
            font-size: 0.9em;
            color: #004085;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ðŸ”— Graph Isomorphism Checker</h1>
        <div class="instructions">
            Click to add vertices, then click two vertices to create edges. Draw two graphs and check if they're isomorphic!
        </div>

        <div class="mode-selector">
            <button class="mode-btn active" onclick="setMode('vertex')">Add Vertex</button>
            <button class="mode-btn" onclick="setMode('edge')">Add Edge</button>
            <button class="mode-btn" onclick="setMode('delete')">Delete</button>
        </div>

        <div class="graphs-container">
            <div class="graph-panel">
                <div class="graph-title">Graph 1</div>
                <canvas id="canvas1" width="500" height="350"></canvas>
                <div class="controls">
                    <button class="btn-danger" onclick="clearGraph(1)">Clear Graph 1</button>
                </div>
            </div>

            <div class="graph-panel">
                <div class="graph-title">Graph 2</div>
                <canvas id="canvas2" width="500" height="350"></canvas>
                <div class="controls">
                    <button class="btn-danger" onclick="clearGraph(2)">Clear Graph 2</button>
                </div>
            </div>
        </div>

        <div class="controls">
            <button class="btn-primary" onclick="checkIsomorphism()">Check Isomorphism</button>
            <button class="btn-primary" onclick="checkPlanarity()">Check Planarity</button>
            <button class="btn-primary" onclick="analyzeGraphProperties()">Analyze Properties</button>
            <button class="btn-primary" onclick="findMinimalSpanningTree()">Find MST</button>
            <button class="btn-primary" onclick="findEulerPath()">Find Euler Path/Cycle</button>
            <button class="btn-secondary" onclick="clearAll()">Clear All</button>
        </div>

        <div id="result" class="result"></div>
        <div id="planarity-result" class="planarity-result"></div>
        <div id="properties-result" class="properties-result"></div>
        <div id="mst-result" class="mst-result"></div>
        <div id="euler-result" class="euler-result"></div>

        <div class="info">
            <strong>How to use:</strong> Select a mode (Add Vertex/Add Edge/Delete), then click on the canvas. 
            For edges, click two vertices in sequence. Two graphs are isomorphic if there's a one-to-one mapping 
            between their vertices that preserves adjacency.
            <br><br>
            <strong>Planarity:</strong> A graph is planar if it CAN be drawn without edge crossings (not whether it currently IS drawn that way). 
            Uses Kuratowski's theorem - checks for Kâ‚… or Kâ‚ƒ,â‚ƒ subgraphs and edge count formula (e â‰¤ 3v-6).
            <br><br>
            <strong>Graph Properties:</strong> Analyze complete, connected, bipartite, Eulerian, Hamiltonian properties and chromatic number.
            <br><br>
            <strong>MST:</strong> Finds Minimum Spanning Tree using Kruskal's algorithm (for connected graphs).
            <br><br>
            <strong>Euler Path/Cycle:</strong> Finds and displays the actual Euler path or cycle if one exists.
        </div>
    </div>

    <script>
        const canvas1 = document.getElementById('canvas1');
        const canvas2 = document.getElementById('canvas2');
        const ctx1 = canvas1.getContext('2d');
        const ctx2 = canvas2.getContext('2d');

        let mode = 'vertex';
        let graphs = {
            1: { vertices: [], edges: [] },
            2: { vertices: [], edges: [] }
        };
        let selectedVertex = { 1: null, 2: null };

        function setMode(newMode) {
            mode = newMode;
            document.querySelectorAll('.mode-btn').forEach(btn => btn.classList.remove('active'));

            // Map mode to button label and add active class to matching button
            const labelMap = {
                'vertex': 'Add Vertex',
                'edge': 'Add Edge',
                'delete': 'Delete'
            };
            const targetLabel = labelMap[newMode];
            document.querySelectorAll('.mode-btn').forEach(btn => {
                if (btn.textContent.trim() === targetLabel) {
                    btn.classList.add('active');
                }
            });

            selectedVertex = { 1: null, 2: null };
            drawGraph(1);
            drawGraph(2);
        }

        function getMousePos(canvas, evt) {
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            return {
                x: (evt.clientX - rect.left) * scaleX,
                y: (evt.clientY - rect.top) * scaleY
            };
        }

        function findVertex(graphNum, x, y) {
            const vertices = graphs[graphNum].vertices;
            for (let i = 0; i < vertices.length; i++) {
                const v = vertices[i];
                const dist = Math.sqrt((x - v.x) ** 2 + (y - v.y) ** 2);
                if (dist < 20) return i;
            }
            return -1;
        }

        canvas1.addEventListener('click', (e) => handleClick(1, e));
        canvas2.addEventListener('click', (e) => handleClick(2, e));

        function handleClick(graphNum, e) {
            const pos = getMousePos(graphNum === 1 ? canvas1 : canvas2, e);
            const vertexIndex = findVertex(graphNum, pos.x, pos.y);

            if (mode === 'vertex' && vertexIndex === -1) {
                graphs[graphNum].vertices.push({ x: pos.x, y: pos.y, id: graphs[graphNum].vertices.length });
                drawGraph(graphNum);
            } else if (mode === 'edge' && vertexIndex !== -1) {
                if (selectedVertex[graphNum] === null) {
                    selectedVertex[graphNum] = vertexIndex;
                } else {
                    if (selectedVertex[graphNum] !== vertexIndex) {
                        const edge = [selectedVertex[graphNum], vertexIndex].sort((a, b) => a - b);
                        const exists = graphs[graphNum].edges.some(e => e[0] === edge[0] && e[1] === edge[1]);
                        if (!exists) {
                            graphs[graphNum].edges.push(edge);
                        }
                    }
                    selectedVertex[graphNum] = null;
                }
                drawGraph(graphNum);
            } else if (mode === 'delete' && vertexIndex !== -1) {
                graphs[graphNum].edges = graphs[graphNum].edges.filter(e => 
                    e[0] !== vertexIndex && e[1] !== vertexIndex
                ).map(e => [
                    e[0] > vertexIndex ? e[0] - 1 : e[0],
                    e[1] > vertexIndex ? e[1] - 1 : e[1]
                ]);
                graphs[graphNum].vertices.splice(vertexIndex, 1);
                graphs[graphNum].vertices.forEach((v, i) => v.id = i);
                drawGraph(graphNum);
            }
        }

        function drawGraph(graphNum) {
            const canvas = graphNum === 1 ? canvas1 : canvas2;
            const ctx = graphNum === 1 ? ctx1 : ctx2;
            const graph = graphs[graphNum];

            // Clear considering CSS scaling
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Draw edges
            ctx.strokeStyle = '#667eea';
            ctx.lineWidth = 2;
            graph.edges.forEach(edge => {
                const v1 = graph.vertices[edge[0]];
                const v2 = graph.vertices[edge[1]];
                if (!v1 || !v2) return;
                ctx.beginPath();
                ctx.moveTo(v1.x, v1.y);
                ctx.lineTo(v2.x, v2.y);
                ctx.stroke();
            });

            // Draw vertices
            graph.vertices.forEach((v, i) => {
                ctx.beginPath();
                ctx.arc(v.x, v.y, 20, 0, 2 * Math.PI);
                ctx.fillStyle = selectedVertex[graphNum] === i ? '#ff6b6b' : '#667eea';
                ctx.fill();
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 3;
                ctx.stroke();

                ctx.fillStyle = '#fff';
                ctx.font = 'bold 14px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(i, v.x, v.y);
            });
        }

        function clearGraph(graphNum) {
            graphs[graphNum] = { vertices: [], edges: [] };
            selectedVertex[graphNum] = null;
            drawGraph(graphNum);
            document.getElementById('result').style.display = 'none';
        }

        function clearAll() {
            clearGraph(1);
            clearGraph(2);
        }

        function getAdjacencyMatrix(graph) {
            const n = graph.vertices.length;
            const matrix = Array(n).fill(0).map(() => Array(n).fill(0));
            graph.edges.forEach(edge => {
                matrix[edge[0]][edge[1]] = 1;
                matrix[edge[1]][edge[0]] = 1;
            });
            return matrix;
        }

        function getDegreeSequence(matrix) {
            return matrix.map(row => row.reduce((a, b) => a + b, 0)).sort((a, b) => a - b);
        }

        function checkIsomorphism() {
            const g1 = graphs[1];
            const g2 = graphs[2];

            if (g1.vertices.length !== g2.vertices.length || g1.edges.length !== g2.edges.length) {
                showResult(false, "Different number of vertices or edges");
                return;
            }

            if (g1.vertices.length === 0) {
                showResult(false, "Both graphs are empty");
                return;
            }

            const adj1 = getAdjacencyMatrix(g1);
            const adj2 = getAdjacencyMatrix(g2);

            const deg1 = getDegreeSequence(adj1);
            const deg2 = getDegreeSequence(adj2);

            if (JSON.stringify(deg1) !== JSON.stringify(deg2)) {
                showResult(false, "Different degree sequences");
                return;
            }

            // Try all permutations for small graphs
            const n = g1.vertices.length;
            if (n > 8) {
                showResult(null, "Graph too large for exact verification (>8 vertices). Degree sequences match.");
                return;
            }

            if (testIsomorphism(adj1, adj2)) {
                showResult(true, "Graphs are isomorphic!");
            } else {
                showResult(false, "Graphs are NOT isomorphic");
            }
        }

        function testIsomorphism(adj1, adj2) {
            const n = adj1.length;
            const perm = Array.from({ length: n }, (_, i) => i);
            
            return permute(perm, 0);

            function permute(arr, start) {
                if (start === arr.length - 1) {
                    if (checkMapping(arr)) return true;
                    return false;
                }

                for (let i = start; i < arr.length; i++) {
                    [arr[start], arr[i]] = [arr[i], arr[start]];
                    if (permute(arr, start + 1)) return true;
                    [arr[start], arr[i]] = [arr[i], arr[start]];
                }
                return false;
            }

            function checkMapping(mapping) {
                for (let i = 0; i < n; i++) {
                    for (let j = 0; j < n; j++) {
                        if (adj1[i][j] !== adj2[mapping[i]][mapping[j]]) {
                            return false;
                        }
                    }
                }
                return true;
            }
        }

        function showResult(isIsomorphic, message) {
            const resultDiv = document.getElementById('result');
            resultDiv.style.display = 'block';
            
            if (isIsomorphic === true) {
                resultDiv.className = 'result isomorphic';
                resultDiv.textContent = 'âœ“ ' + message;
            } else if (isIsomorphic === false) {
                resultDiv.className = 'result not-isomorphic';
                resultDiv.textContent = 'âœ— ' + message;
            } else {
                resultDiv.className = 'result';
                resultDiv.style.display = 'block';
                resultDiv.style.background = '#fff3cd';
                resultDiv.style.color = '#856404';
                resultDiv.style.border = '2px solid #ffeaa7';
                resultDiv.textContent = 'âš  ' + message;
            }
        }

        function checkPlanarity() {
            const results = [];
            
            for (let graphNum = 1; graphNum <= 2; graphNum++) {
                const graph = graphs[graphNum];
                const v = graph.vertices.length;
                const e = graph.edges.length;
                
                if (v === 0) {
                    results.push({ graphNum, planar: true, reason: "Empty graph (trivially planar)" });
                    continue;
                }
                
                if (v === 1 || v === 2) {
                    results.push({ graphNum, planar: true, reason: "â‰¤2 vertices (trivially planar)" });
                    continue;
                }
                
                // Euler's formula check: e <= 3v - 6 for planar graphs with v >= 3
                if (e > 3 * v - 6) {
                    results.push({ graphNum, planar: false, reason: `Too many edges: ${e} > ${3*v-6}` });
                    continue;
                }
                
                // Check for K5 or K3,3 subgraphs (Kuratowski's theorem)
                const adj = getAdjacencyMatrix(graph);
                
                // Check for K5 (complete graph on 5 vertices)
                if (hasK5(adj)) {
                    results.push({ graphNum, planar: false, reason: "Contains Kâ‚… subgraph" });
                    continue;
                }
                
                // Check for K3,3 (complete bipartite graph)
                if (hasK33(adj)) {
                    results.push({ graphNum, planar: false, reason: "Contains Kâ‚ƒ,â‚ƒ subgraph" });
                    continue;
                }
                
                results.push({ graphNum, planar: true, reason: "No Kâ‚… or Kâ‚ƒ,â‚ƒ found, passes planarity tests" });
            }
            
            showPlanarityResult(results);
        }

        function hasK5(adj) {
            const n = adj.length;
            if (n < 5) return false;
            
            // Check all combinations of 5 vertices
            for (let i = 0; i < n - 4; i++) {
                for (let j = i + 1; j < n - 3; j++) {
                    for (let k = j + 1; k < n - 2; k++) {
                        for (let l = k + 1; l < n - 1; l++) {
                            for (let m = l + 1; m < n; m++) {
                                const vertices = [i, j, k, l, m];
                                if (isCompleteSubgraph(adj, vertices)) {
                                    return true;
                                }
                            }
                        }
                    }
                }
            }
            return false;
        }

        function hasK33(adj) {
            const n = adj.length;
            if (n < 6) return false;
            
            // Check all combinations of 6 vertices for K3,3
            for (let i = 0; i < n - 5; i++) {
                for (let j = i + 1; j < n - 4; j++) {
                    for (let k = j + 1; k < n - 3; k++) {
                        for (let l = k + 1; l < n - 2; l++) {
                            for (let m = l + 1; m < n - 1; m++) {
                                for (let o = m + 1; o < n; o++) {
                                    const vertices = [i, j, k, l, m, o];
                                    if (isK33Subgraph(adj, vertices)) {
                                        return true;
                                    }
                                }
                            }
                        }
                    }
                }
            }
            return false;
        }

        function isCompleteSubgraph(adj, vertices) {
            for (let i = 0; i < vertices.length; i++) {
                for (let j = i + 1; j < vertices.length; j++) {
                    if (adj[vertices[i]][vertices[j]] === 0) {
                        return false;
                    }
                }
            }
            return true;
        }

        function isK33Subgraph(adj, vertices) {
            // Try all possible partitions of 6 vertices into two sets of 3
            const partitions = [
                [[0, 1, 2], [3, 4, 5]],
                [[0, 1, 3], [2, 4, 5]],
                [[0, 1, 4], [2, 3, 5]],
                [[0, 1, 5], [2, 3, 4]],
                [[0, 2, 3], [1, 4, 5]],
                [[0, 2, 4], [1, 3, 5]],
                [[0, 2, 5], [1, 3, 4]],
                [[0, 3, 4], [1, 2, 5]],
                [[0, 3, 5], [1, 2, 4]],
                [[0, 4, 5], [1, 2, 3]]
            ];
            
            for (const [set1, set2] of partitions) {
                let isK33 = true;
                
                // Check all edges between sets exist
                for (const i of set1) {
                    for (const j of set2) {
                        if (adj[vertices[i]][vertices[j]] === 0) {
                            isK33 = false;
                            break;
                        }
                    }
                    if (!isK33) break;
                }
                
                if (!isK33) continue;
                
                // Check no edges within sets
                for (let i = 0; i < set1.length - 1; i++) {
                    for (let j = i + 1; j < set1.length; j++) {
                        if (adj[vertices[set1[i]]][vertices[set1[j]]] === 1) {
                            isK33 = false;
                            break;
                        }
                    }
                    if (!isK33) break;
                }
                
                if (!isK33) continue;
                
                for (let i = 0; i < set2.length - 1; i++) {
                    for (let j = i + 1; j < set2.length; j++) {
                        if (adj[vertices[set2[i]]][vertices[set2[j]]] === 1) {
                            isK33 = false;
                            break;
                        }
                    }
                    if (!isK33) break;
                }
                
                if (isK33) return true;
            }
            
            return false;
        }

        function showPlanarityResult(results) {
            const resultDiv = document.getElementById('planarity-result');
            let message = '';
            
            for (const result of results) {
                const status = result.planar ? 'âœ“ PLANAR' : 'âœ— NON-PLANAR';
                message += `Graph ${result.graphNum}: ${status} - ${result.reason}\n`;
            }
            
            resultDiv.textContent = message;
            
            const allPlanar = results.every(r => r.planar);
            const anyNonPlanar = results.some(r => !r.planar);
            
            if (anyNonPlanar) {
                resultDiv.className = 'planarity-result non-planar';
            } else if (allPlanar) {
                resultDiv.className = 'planarity-result planar';
            }
            
            resultDiv.style.whiteSpace = 'pre-line';
        }

        function analyzeGraphProperties() {
            const resultsDiv = document.getElementById('properties-result');
            resultsDiv.innerHTML = '';
            
            for (let graphNum = 1; graphNum <= 2; graphNum++) {
                const graph = graphs[graphNum];
                const v = graph.vertices.length;
                const e = graph.edges.length;
                
                if (v === 0) {
                    const section = document.createElement('div');
                    section.className = 'property-section';
                    section.innerHTML = `<div class="property-title">Graph ${graphNum}: Empty Graph</div>`;
                    resultsDiv.appendChild(section);
                    continue;
                }
                
                const adj = getAdjacencyMatrix(graph);
                
                // Check all properties
                const isComplete = checkComplete(adj);
                const isConnected = checkConnected(adj);
                const isBipartiteResult = isBipartite(adj);
                const eulerInfo = checkEulerCycle(adj);
                const hamiltonianInfo = checkHamiltonianCircuit(adj, graph);
                const chromaticNumber = calculateChromaticNumber(adj);
                
                // Create display section
                const section = document.createElement('div');
                section.className = 'property-section';
                
                let html = `<div class="property-title">Graph ${graphNum} Analysis</div>`;
                html += `<div class="property-detail">Vertices: ${v}, Edges: ${e}</div>`;
                html += `<div class="property-detail"><strong>Complete:</strong> <span class="property-${isComplete ? 'yes' : 'no'}">${isComplete ? 'YES' : 'NO'}</span></div>`;
                html += `<div class="property-detail"><strong>Connected:</strong> <span class="property-${isConnected ? 'yes' : 'no'}">${isConnected ? 'YES' : 'NO'}</span></div>`;
                html += `<div class="property-detail"><strong>Bipartite:</strong> <span class="property-${isBipartiteResult ? 'yes' : 'no'}">${isBipartiteResult ? 'YES' : 'NO'}</span></div>`;
                html += `<div class="property-detail"><strong>Euler Cycle:</strong> <span class="property-${eulerInfo.hasEulerCycle ? 'yes' : 'no'}">${eulerInfo.hasEulerCycle ? 'YES' : 'NO'}</span> ${eulerInfo.reason}</div>`;
                html += `<div class="property-detail"><strong>Hamiltonian Circuit:</strong> <span class="property-${hamiltonianInfo.hasHamiltonian ? 'yes' : 'no'}">${hamiltonianInfo.hasHamiltonian ? 'YES' : 'NO'}</span> ${hamiltonianInfo.reason}</div>`;
                html += `<div class="property-detail"><strong>Chromatic Number:</strong> Ï‡ = ${chromaticNumber}</div>`;
                
                section.innerHTML = html;
                resultsDiv.appendChild(section);
            }
            
            resultsDiv.className = 'properties-result show';
        }

        function checkComplete(adj) {
            const n = adj.length;
            if (n <= 1) return true;
            
            for (let i = 0; i < n; i++) {
                for (let j = i + 1; j < n; j++) {
                    if (adj[i][j] === 0) return false;
                }
            }
            return true;
        }

        function checkConnected(adj) {
            const n = adj.length;
            if (n <= 1) return true;
            
            const visited = new Array(n).fill(false);
            
            // DFS from vertex 0
            function dfs(v) {
                visited[v] = true;
                for (let i = 0; i < n; i++) {
                    if (adj[v][i] === 1 && !visited[i]) {
                        dfs(i);
                    }
                }
            }
            
            dfs(0);
            return visited.every(v => v);
        }

        function checkEulerCycle(adj) {
            const n = adj.length;
            
            if (!checkConnected(adj)) {
                return { hasEulerCycle: false, reason: '(graph not connected)' };
            }
            
            // Count degree of each vertex
            const degrees = adj.map(row => row.reduce((sum, val) => sum + val, 0));
            
            const oddDegreeCount = degrees.filter(d => d % 2 === 1).length;
            
            if (oddDegreeCount === 0) {
                return { hasEulerCycle: true, reason: '(all vertices have even degree)' };
            } else if (oddDegreeCount === 2) {
                return { hasEulerCycle: false, reason: '(has Euler path but not cycle - 2 odd degree vertices)' };
            } else {
                return { hasEulerCycle: false, reason: `(${oddDegreeCount} vertices with odd degree)` };
            }
        }

        function checkHamiltonianCircuit(adj, graph) {
            const n = adj.length;
            
            if (n < 3) {
                return { hasHamiltonian: false, reason: '(needs at least 3 vertices)' };
            }
            
            if (!checkConnected(adj)) {
                return { hasHamiltonian: false, reason: '(graph not connected)' };
            }
            
            // For small graphs, try to find a Hamiltonian circuit using backtracking
            if (n <= 8) {
                const path = [0];
                const visited = new Array(n).fill(false);
                visited[0] = true;
                
                if (findHamiltonianPath(adj, path, visited, n)) {
                    return { hasHamiltonian: true, reason: '(circuit found)' };
                } else {
                    return { hasHamiltonian: false, reason: '(no circuit found)' };
                }
            } else {
                // Use Dirac's theorem: if every vertex has degree >= n/2, then Hamiltonian
                const degrees = adj.map(row => row.reduce((sum, val) => sum + val, 0));
                const minDegree = Math.min(...degrees);
                
                if (minDegree >= n / 2) {
                    return { hasHamiltonian: true, reason: "(Dirac's theorem - min degree â‰¥ n/2)" };
                } else {
                    return { hasHamiltonian: false, reason: '(cannot verify for large graphs)' };
                }
            }
        }

        function findHamiltonianPath(adj, path, visited, n) {
            if (path.length === n) {
                // Check if there's an edge back to start
                return adj[path[path.length - 1]][path[0]] === 1;
            }
            
            const current = path[path.length - 1];
            
            for (let next = 0; next < n; next++) {
                if (adj[current][next] === 1 && !visited[next]) {
                    path.push(next);
                    visited[next] = true;
                    
                    if (findHamiltonianPath(adj, path, visited, n)) {
                        return true;
                    }
                    
                    path.pop();
                    visited[next] = false;
                }
            }
            
            return false;
        }

        function calculateChromaticNumber(adj) {
            const n = adj.length;
            if (n === 0) return 0;
            if (n === 1) return 1;
            
            // Check if bipartite (chromatic number = 2)
            if (isBipartite(adj)) return 2;
            
            // Check if complete graph (chromatic number = n)
            if (checkComplete(adj)) return n;
            
            // Try greedy coloring with different orderings
            let minColors = n;
            
            for (let attempt = 0; attempt < 3; attempt++) {
                const colors = new Array(n).fill(-1);
                const vertices = Array.from({ length: n }, (_, i) => i);
                
                if (attempt === 1) {
                    // Sort by degree (largest first)
                    const degrees = adj.map(row => row.reduce((sum, val) => sum + val, 0));
                    vertices.sort((a, b) => degrees[b] - degrees[a]);
                } else if (attempt === 2) {
                    // Random order
                    vertices.sort(() => Math.random() - 0.5);
                }
                
                for (const v of vertices) {
                    const usedColors = new Set();
                    
                    for (let i = 0; i < n; i++) {
                        if (adj[v][i] === 1 && colors[i] !== -1) {
                            usedColors.add(colors[i]);
                        }
                    }
                    
                    for (let color = 0; color < n; color++) {
                        if (!usedColors.has(color)) {
                            colors[v] = color;
                            break;
                        }
                    }
                }
                
                const numColors = Math.max(...colors) + 1;
                minColors = Math.min(minColors, numColors);
            }
            
            return minColors;
        }

        function isBipartite(adj) {
            const n = adj.length;
            const colors = new Array(n).fill(-1);
            
            for (let start = 0; start < n; start++) {
                if (colors[start] !== -1) continue;
                
                const queue = [start];
                colors[start] = 0;
                
                while (queue.length > 0) {
                    const v = queue.shift();
                    
                    for (let i = 0; i < n; i++) {
                        if (adj[v][i] === 1) {
                            if (colors[i] === -1) {
                                colors[i] = 1 - colors[v];
                                queue.push(i);
                            } else if (colors[i] === colors[v]) {
                                return false;
                            }
                        }
                    }
                }
            }
            
            return true;
        }

        // Minimal Spanning Tree (Kruskal) UI function & helpers
        function findMinimalSpanningTree() {
            const resultsDiv = document.getElementById('mst-result');
            resultsDiv.innerHTML = '';
            
            for (let graphNum = 1; graphNum <= 2; graphNum++) {
                const graph = graphs[graphNum];
                const v = graph.vertices.length;
                const e = graph.edges.length;
                
                if (v === 0) {
                    const section = document.createElement('div');
                    section.className = 'property-section';
                    section.innerHTML = `<div class="property-title">Graph ${graphNum}: Empty Graph</div>`;
                    resultsDiv.appendChild(section);
                    continue;
                }
                
                const adj = getAdjacencyMatrix(graph);
                
                if (!checkConnected(adj)) {
                    const section = document.createElement('div');
                    section.className = 'property-section';
                    section.innerHTML = `
                        <div class="property-title">Graph ${graphNum}: MST Not Possible</div>
                        <div class="property-detail">Graph is not connected - MST only exists for connected graphs</div>
                    `;
                    resultsDiv.appendChild(section);
                    continue;
                }
                
                // Use Kruskal's algorithm
                const mst = kruskalMST(graph);
                
                const section = document.createElement('div');
                section.className = 'property-section';
                let html = `<div class="property-title">Graph ${graphNum}: Minimum Spanning Tree</div>`;
                html += `<div class="property-detail">MST has ${mst.length} edges (spanning ${v} vertices)</div>`;
                html += `<div class="property-detail"><strong>Edges in MST:</strong></div>`;
                
                mst.forEach((edge, i) => {
                    html += `<div class="property-detail">  ${i+1}. <span class="path-highlight">(${edge[0]} - ${edge[1]})</span></div>`;
                });
                
                section.innerHTML = html;
                resultsDiv.appendChild(section);
            }
            
            resultsDiv.className = 'mst-result show';
        }

        function kruskalMST(graph) {
            const edges = graph.edges.slice();
            const parent = Array.from({ length: graph.vertices.length }, (_, i) => i);
            const mst = [];
            
            function find(x) {
                if (parent[x] !== x) {
                    parent[x] = find(parent[x]);
                }
                return parent[x];
            }
            
            function union(x, y) {
                const rootX = find(x);
                const rootY = find(y);
                if (rootX !== rootY) {
                    parent[rootX] = rootY;
                    return true;
                }
                return false;
            }
            
            // Sort edges by their indices (could use weights if we had them)
            edges.sort((a, b) => (a[0] + a[1]) - (b[0] + b[1]));
            
            for (const edge of edges) {
                if (union(edge[0], edge[1])) {
                    mst.push(edge);
                    if (mst.length === graph.vertices.length - 1) break;
                }
            }
            
            return mst;
        }

        // Euler path/cycle UI and algorithm
        function findEulerPath() {
            const resultsDiv = document.getElementById('euler-result');
            resultsDiv.innerHTML = '';
            
            for (let graphNum = 1; graphNum <= 2; graphNum++) {
                const graph = graphs[graphNum];
                const v = graph.vertices.length;
                
                if (v === 0) {
                    const section = document.createElement('div');
                    section.className = 'property-section';
                    section.innerHTML = `<div class="property-title">Graph ${graphNum}: Empty Graph</div>`;
                    resultsDiv.appendChild(section);
                    continue;
                }
                
                const adj = getAdjacencyMatrix(graph);
                
                if (!checkConnected(adj)) {
                    const section = document.createElement('div');
                    section.className = 'property-section';
                    section.innerHTML = `
                        <div class="property-title">Graph ${graphNum}: No Euler Path/Cycle</div>
                        <div class="property-detail">Graph is not connected</div>
                    `;
                    resultsDiv.appendChild(section);
                    continue;
                }
                
                // Count odd degree vertices
                const degrees = adj.map(row => row.reduce((sum, val) => sum + val, 0));
                const oddDegreeVertices = [];
                degrees.forEach((deg, idx) => {
                    if (deg % 2 === 1) oddDegreeVertices.push(idx);
                });
                
                const section = document.createElement('div');
                section.className = 'property-section';
                let html = `<div class="property-title">Graph ${graphNum}: Euler Path/Cycle</div>`;
                
                if (oddDegreeVertices.length === 0) {
                    // Has Euler cycle
                    const path = findEulerianPath(graph, adj, 0, true);
                    html += `<div class="property-detail"><strong>Result:</strong> <span class="property-yes">Euler Cycle Found!</span></div>`;
                    html += `<div class="property-detail"><strong>Cycle:</strong></div>`;
                    html += `<div class="property-detail"><span class="path-highlight">${path.join(' â†’ ')}</span></div>`;
                } else if (oddDegreeVertices.length === 2) {
                    // Has Euler path
                    const path = findEulerianPath(graph, adj, oddDegreeVertices[0], false);
                    html += `<div class="property-detail"><strong>Result:</strong> <span class="property-yes">Euler Path Found!</span> (no cycle)</div>`;
                    html += `<div class="property-detail">Path must start at vertex ${oddDegreeVertices[0]} or ${oddDegreeVertices[1]}</div>`;
                    html += `<div class="property-detail"><strong>Path:</strong></div>`;
                    html += `<div class="property-detail"><span class="path-highlight">${path.join(' â†’ ')}</span></div>`;
                } else {
                    html += `<div class="property-detail"><strong>Result:</strong> <span class="property-no">No Euler Path or Cycle</span></div>`;
                    html += `<div class="property-detail">Graph has ${oddDegreeVertices.length} vertices with odd degree</div>`;
                    html += `<div class="property-detail">Odd degree vertices: ${oddDegreeVertices.join(', ')}</div>`;
                }
                
                section.innerHTML = html;
                resultsDiv.appendChild(section);
            }
            
            resultsDiv.className = 'euler-result show';
        }

        function findEulerianPath(graph, adj, startVertex, isCycle) {
            // Hierholzer's algorithm
            const n = adj.length;
            const adjCopy = adj.map(row => row.slice());
            const stack = [startVertex];
            const path = [];
            
            while (stack.length > 0) {
                const v = stack[stack.length - 1];
                let foundEdge = false;
                
                for (let u = 0; u < n; u++) {
                    if (adjCopy[v][u] === 1) {
                        stack.push(u);
                        adjCopy[v][u] = 0;
                        adjCopy[u][v] = 0;
                        foundEdge = true;
                        break;
                    }
                }
                
                if (!foundEdge) {
                    path.push(stack.pop());
                }
            }
            
            return path.reverse();
        }

        // Initialize
        drawGraph(1);
        drawGraph(2);
    </script>
</body>
</html>
